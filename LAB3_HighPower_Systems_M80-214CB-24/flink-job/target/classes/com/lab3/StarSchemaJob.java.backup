package com.lab3;

import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import org.apache.flink.api.common.serialization.SimpleStringSchema;
import org.apache.flink.connector.jdbc.JdbcConnectionOptions;
import org.apache.flink.connector.jdbc.JdbcExecutionOptions;
import org.apache.flink.connector.jdbc.JdbcSink;
import org.apache.flink.connector.kafka.source.KafkaSource;
import org.apache.flink.connector.kafka.source.enumerator.initializer.OffsetsInitializer;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.ProcessFunction;
import org.apache.flink.util.Collector;
import org.json.JSONObject;

import java.sql.Date;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.Map;

public class StarSchemaJob {
    
    public static void main(String[] args) throws Exception {
        // Создание окружения Flink
        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        
        // Настройка Kafka Source
        KafkaSource<String> source = KafkaSource.<String>builder()
            .setBootstrapServers("kafka:9092")
            .setTopics("petstore-transactions")
            .setGroupId("flink-star-schema-group")
            .setStartingOffsets(OffsetsInitializer.earliest())
            .setValueOnlyDeserializer(new SimpleStringSchema())
            .build();
        
        // Чтение данных из Kafka
        DataStream<String> jsonStream = env.fromSource(
            source,
            WatermarkStrategy.noWatermarks(),
            "Kafka Source"
        );
        
        // Парсинг JSON и преобразование в модель звезда
        DataStream<Map<String, Object>> parsedStream = jsonStream
            .process(new ProcessFunction<String, Map<String, Object>>() {
                @Override
                public void processElement(
                    String value, 
                    ProcessFunction<String, Map<String, Object>>.Context ctx, 
                    Collector<Map<String, Object>> out
                ) throws Exception {
                    try {
                        JSONObject json = new JSONObject(value);
                        Map<String, Object> record = new HashMap<>();
                        
                        // Извлечение всех полей
                        json.keySet().forEach(key -> {
                            record.put(key, json.get(key));
                        });
                        
                        out.collect(record);
                    } catch (Exception e) {
                        System.err.println("Ошибка парсинга JSON: " + e.getMessage());
                    }
                }
            });
        
        // Сохранение в таблицу dim_customer
        parsedStream.addSink(
            JdbcSink.sink(
                "INSERT INTO dim_customer (customer_first_name, customer_last_name, customer_age, " +
                "customer_email, customer_country, customer_postal_code, customer_pet_type, " +
                "customer_pet_name, customer_pet_breed) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) " +
                "ON CONFLICT (customer_email) DO UPDATE SET " +
                "customer_first_name = EXCLUDED.customer_first_name, " +
                "customer_last_name = EXCLUDED.customer_last_name, " +
                "customer_age = EXCLUDED.customer_age, " +
                "customer_country = EXCLUDED.customer_country, " +
                "customer_postal_code = EXCLUDED.customer_postal_code, " +
                "customer_pet_type = EXCLUDED.customer_pet_type, " +
                "customer_pet_name = EXCLUDED.customer_pet_name, " +
                "customer_pet_breed = EXCLUDED.customer_pet_breed",
                (statement, record) -> {
                    statement.setString(1, record.get("customer_first_name").toString());
                    statement.setString(2, record.get("customer_last_name").toString());
                    statement.setInt(3, Integer.parseInt(record.get("customer_age").toString()));
                    statement.setString(4, record.get("customer_email").toString());
                    statement.setString(5, record.get("customer_country").toString());
                    statement.setString(6, record.get("customer_postal_code") != null ? 
                        record.get("customer_postal_code").toString() : null);
                    statement.setString(7, record.get("customer_pet_type").toString());
                    statement.setString(8, record.get("customer_pet_name").toString());
                    statement.setString(9, record.get("customer_pet_breed").toString());
                },
                JdbcExecutionOptions.builder()
                    .withBatchSize(1000)
                    .withBatchIntervalMs(200)
                    .withMaxRetries(5)
                    .build(),
                new JdbcConnectionOptions.JdbcConnectionOptionsBuilder()
                    .withUrl("jdbc:postgresql://postgres-lab3:5432/petstore")
                    .withDriverName("org.postgresql.Driver")
                    .withUsername("admin")
                    .withPassword("password")
                    .build()
            )
        ).name("Save to dim_customer");
        
        // Сохранение в таблицу dim_seller
        parsedStream.addSink(
            JdbcSink.sink(
                "INSERT INTO dim_seller (seller_first_name, seller_last_name, seller_email, " +
                "seller_country, seller_postal_code) " +
                "VALUES (?, ?, ?, ?, ?) " +
                "ON CONFLICT (seller_email) DO UPDATE SET " +
                "seller_first_name = EXCLUDED.seller_first_name, " +
                "seller_last_name = EXCLUDED.seller_last_name, " +
                "seller_country = EXCLUDED.seller_country, " +
                "seller_postal_code = EXCLUDED.seller_postal_code",
                (statement, record) -> {
                    statement.setString(1, record.get("seller_first_name").toString());
                    statement.setString(2, record.get("seller_last_name").toString());
                    statement.setString(3, record.get("seller_email").toString());
                    statement.setString(4, record.get("seller_country").toString());
                    statement.setString(5, record.get("seller_postal_code") != null ? 
                        record.get("seller_postal_code").toString() : null);
                },
                JdbcExecutionOptions.builder()
                    .withBatchSize(1000)
                    .withBatchIntervalMs(200)
                    .withMaxRetries(5)
                    .build(),
                new JdbcConnectionOptions.JdbcConnectionOptionsBuilder()
                    .withUrl("jdbc:postgresql://postgres-lab3:5432/petstore")
                    .withDriverName("org.postgresql.Driver")
                    .withUsername("admin")
                    .withPassword("password")
                    .build()
            )
        ).name("Save to dim_seller");
        
        // Сохранение в таблицу dim_product
        parsedStream.addSink(
            JdbcSink.sink(
                "INSERT INTO dim_product (product_name, product_category, product_price, " +
                "product_quantity, product_weight, product_color, product_size, product_brand, " +
                "product_material, product_description, product_rating, product_reviews, " +
                "product_release_date, product_expiry_date, supplier_name, supplier_contact, " +
                "supplier_email, supplier_phone, supplier_address, supplier_city, " +
                "supplier_country, pet_category) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) " +
                "ON CONFLICT (product_name, product_brand) DO UPDATE SET " +
                "product_category = EXCLUDED.product_category, " +
                "product_price = EXCLUDED.product_price, " +
                "product_quantity = EXCLUDED.product_quantity, " +
                "product_weight = EXCLUDED.product_weight, " +
                "product_color = EXCLUDED.product_color, " +
                "product_size = EXCLUDED.product_size, " +
                "product_material = EXCLUDED.product_material, " +
                "product_description = EXCLUDED.product_description, " +
                "product_rating = EXCLUDED.product_rating, " +
                "product_reviews = EXCLUDED.product_reviews, " +
                "product_release_date = EXCLUDED.product_release_date, " +
                "product_expiry_date = EXCLUDED.product_expiry_date, " +
                "pet_category = EXCLUDED.pet_category",
                (statement, record) -> {
                    statement.setString(1, record.get("product_name").toString());
                    statement.setString(2, record.get("product_category").toString());
                    statement.setDouble(3, Double.parseDouble(record.get("product_price").toString()));
                    statement.setInt(4, Integer.parseInt(record.get("product_quantity").toString()));
                    statement.setDouble(5, Double.parseDouble(record.get("product_weight").toString()));
                    statement.setString(6, record.get("product_color").toString());
                    statement.setString(7, record.get("product_size").toString());
                    statement.setString(8, record.get("product_brand").toString());
                    statement.setString(9, record.get("product_material").toString());
                    statement.setString(10, record.get("product_description").toString());
                    statement.setDouble(11, Double.parseDouble(record.get("product_rating").toString()));
                    statement.setInt(12, Integer.parseInt(record.get("product_reviews").toString()));
                    
                    // Парсинг дат
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("M/d/yyyy");
                    LocalDate releaseDate = LocalDate.parse(record.get("product_release_date").toString(), formatter);
                    LocalDate expiryDate = LocalDate.parse(record.get("product_expiry_date").toString(), formatter);
                    
                    statement.setDate(13, Date.valueOf(releaseDate));
                    statement.setDate(14, Date.valueOf(expiryDate));
                    
                    statement.setString(15, record.get("supplier_name").toString());
                    statement.setString(16, record.get("supplier_contact").toString());
                    statement.setString(17, record.get("supplier_email").toString());
                    statement.setString(18, record.get("supplier_phone").toString());
                    statement.setString(19, record.get("supplier_address").toString());
                    statement.setString(20, record.get("supplier_city").toString());
                    statement.setString(21, record.get("supplier_country").toString());
                    statement.setString(22, record.get("pet_category").toString());
                },
                JdbcExecutionOptions.builder()
                    .withBatchSize(1000)
                    .withBatchIntervalMs(200)
                    .withMaxRetries(5)
                    .build(),
                new JdbcConnectionOptions.JdbcConnectionOptionsBuilder()
                    .withUrl("jdbc:postgresql://postgres-lab3:5432/petstore")
                    .withDriverName("org.postgresql.Driver")
                    .withUsername("admin")
                    .withPassword("password")
                    .build()
            )
        ).name("Save to dim_product");
        
        // Сохранение в таблицу dim_store
        parsedStream.addSink(
            JdbcSink.sink(
                "INSERT INTO dim_store (store_name, store_location, store_city, " +
                "store_state, store_country, store_phone, store_email) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?) " +
                "ON CONFLICT (store_name, store_location) DO UPDATE SET " +
                "store_city = EXCLUDED.store_city, " +
                "store_state = EXCLUDED.store_state, " +
                "store_country = EXCLUDED.store_country, " +
                "store_phone = EXCLUDED.store_phone, " +
                "store_email = EXCLUDED.store_email",
                (statement, record) -> {
                    statement.setString(1, record.get("store_name").toString());
                    statement.setString(2, record.get("store_location").toString());
                    statement.setString(3, record.get("store_city").toString());
                    statement.setString(4, record.get("store_state") != null ? 
                        record.get("store_state").toString() : null);
                    statement.setString(5, record.get("store_country").toString());
                    statement.setString(6, record.get("store_phone").toString());
                    statement.setString(7, record.get("store_email").toString());
                },
                JdbcExecutionOptions.builder()
                    .withBatchSize(1000)
                    .withBatchIntervalMs(200)
                    .withMaxRetries(5)
                    .build(),
                new JdbcConnectionOptions.JdbcConnectionOptionsBuilder()
                    .withUrl("jdbc:postgresql://postgres-lab3:5432/petstore")
                    .withDriverName("org.postgresql.Driver")
                    .withUsername("admin")
                    .withPassword("password")
                    .build()
            )
        ).name("Save to dim_store");
        
        // Сохранение в таблицу dim_time
        parsedStream.addSink(
            JdbcSink.sink(
                "INSERT INTO dim_time (sale_date, sale_year, sale_month, sale_day, " +
                "sale_quarter, sale_day_of_week) " +
                "VALUES (?, ?, ?, ?, ?, ?) " +
                "ON CONFLICT (sale_date) DO NOTHING",
                (statement, record) -> {
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("M/d/yyyy");
                    LocalDate saleDate = LocalDate.parse(record.get("sale_date").toString(), formatter);
                    
                    statement.setDate(1, Date.valueOf(saleDate));
                    statement.setInt(2, saleDate.getYear());
                    statement.setInt(3, saleDate.getMonthValue());
                    statement.setInt(4, saleDate.getDayOfMonth());
                    statement.setInt(5, (saleDate.getMonthValue() - 1) / 3 + 1);
                    statement.setString(6, saleDate.getDayOfWeek().toString());
                },
                JdbcExecutionOptions.builder()
                    .withBatchSize(1000)
                    .withBatchIntervalMs(200)
                    .withMaxRetries(5)
                    .build(),
                new JdbcConnectionOptions.JdbcConnectionOptionsBuilder()
                    .withUrl("jdbc:postgresql://postgres-lab3:5432/petstore")
                    .withDriverName("org.postgresql.Driver")
                    .withUsername("admin")
                    .withPassword("password")
                    .build()
            )
        ).name("Save to dim_time");
        
        // Запуск Flink job
        System.out.println("Запуск Flink Star Schema Job...");
        env.execute("Star Schema Transformation Job");
    }
}